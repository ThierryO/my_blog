{
  "hash": "fa129c9ad8b0db1b73b9fa3d2a8826b8",
  "result": {
    "markdown": "---\ntitle: Comparing inlabru with INLA\nauthor: Thierry Onkelinx\ndate: \"2018-02-16\"\ncategories: [statistics, mixed-models]\nimage: inlabru_files/figure-html/fig-plot-fixed-1.svg\nknitr:\n  opts_chunk: \n    dev: \"svg\"\n    echo: true\n    message: false\n---\n\n\n[`inlabru`](https://www.inlabru.org) is an R package which builds on top of the [`INLA`](https://www.r-inla.org) package.\nI had the opportunity to take a workshop on it during the International Statistical Ecology Workshop [\nISEC2018<!-- spell-check: ignore -->\n](https://www.isec2018.org) in St Andrews.\nThis was a five day workshop condensed into a single day, hence the pace was very high.\nIt gave us a good overview of the possibilities of `inlabru` but no time to try it on our own data.\n_This is an updated version of the original post due to changes in the package used in the original post._\n\n`inlabru` has two main functions: [`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) and [`lgcp()`](https://inlabru-org.github.io/inlabru/reference/lgcp.html).\n[`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) is a wrapper for `INLA::inla()`.\n[`lgcp()`](https://inlabru-org.github.io/inlabru/reference/lgcp.html) is intended to fit log Gaussian Cox processes.\nI will focus on `bru` and compare it with `INLA::inla()` as I find that [`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) makes things a lot easier.\n\n# Tundra bean goose\n\nThe test data is derived from the \"Wintering waterbirds in Flanders, Belgium\", freely available at GBIF (https://doi.org/10.15468/lj0udq).\nI've extracted the observations from the [tundra bean goose](https://www.gbif.org/species/6178319)\n(_Anser fabalis rossicus_, @fig-tundra-bean-goose).<!-- spell-check: ignore -->\nThe dataset was limited to those locations with at least 6 occurrences during at least 3 years.\nMonths with lower number of count were removed.\n@fig-observed-total indicates the sum of all observed geese in the data.\nNote that these totals are somewhat misleading since there are a fair amount of missing observations (@fig-missing).\nThe geographic distribution of the data is given in @fig-map-goose.\n\n![Tundra bean goose\n_Anser fabalis rossicus_<!-- spell-check: ignore -->\nby [\nRoar Ottesen<!-- spell-check: ignore -->\n](https://www.gbif.org/occurrence/1798469433) CC BY 4.0](media/tundra-bean-goose.jpg){#fig-tundra-bean-goose}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaflet)\nlibrary(scales)\nlibrary(sf)\nlibrary(tidyverse)\ngoose <- readRDS(\"data/anser_fabalis_rossicus.rds\")\nset.seed(20180712)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Time series of observed total counts for tundra bean goose](inlabru_files/figure-html/fig-observed-total-1.svg){#fig-observed-total width=672}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Time series of missingness in the data](inlabru_files/figure-html/fig-missing-1.svg){#fig-missing width=672}\n:::\n:::\n\n::: {.cell}\n::: {#fig-map-goose .cell-output-display}\n```{=html}\n<div class=\"leaflet html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-2593d0f2cc69fc94163d\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-2593d0f2cc69fc94163d\">{\"x\":{\"options\":{\"crs\":{\"crsClass\":\"L.CRS.EPSG3857\",\"code\":null,\"proj4def\":null,\"projectedBounds\":null,\"options\":{}}},\"calls\":[{\"method\":\"addTiles\",\"args\":[\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",null,null,{\"minZoom\":0,\"maxZoom\":18,\"tileSize\":256,\"subdomains\":\"abc\",\"errorTileUrl\":\"\",\"tms\":false,\"noWrap\":false,\"zoomOffset\":0,\"zoomReverse\":false,\"opacity\":1,\"zIndex\":1,\"detectRetina\":false,\"attribution\":\"&copy; <a href=\\\"https://openstreetmap.org\\\">OpenStreetMap<\\/a> contributors, <a href=\\\"https://creativecommons.org/licenses/by-sa/2.0/\\\">CC-BY-SA<\\/a>\"}]},{\"method\":\"addCircleMarkers\",\"args\":[[50.9788835,50.9958564,50.9732169,50.9647426,50.9477202,50.937619,51.0732877,51.2685615,51.2479447,51.2491686,51.2748924,51.025417,51.0956499,51.3138271,51.3367043,51.3028393,51.3633619,51.2283106,50.9587652,51.1388332,51.1006388,50.9482982,50.980579,51.0518778,51.0718632,50.9027638,51.180548,51.1167112],[2.8243952,2.8418923,2.8580705,2.8075327,2.8256848,2.8073042,2.8586397,3.6692457,3.7177159,3.7598638,3.5680443,3.9236479,4.508256,4.6454059,4.7177102,4.2072618,4.9349367,5.1535041,5.1517106,5.8282973,5.8200067,5.720435,5.7319947,5.7607448,5.7865559,5.6932838,5.6626904,5.6645078],[5.805991626444959,0.7366764995363201,2.348908546648643,5.491316467946866,4.315533093739416,5.519958283344999,0.927058084855655,10.4760801667378,6.268625648250565,11.84392931367834,7.795399348251741,1.085783359784267,1.256885108462627,1.995734068776223,21.22348724573567,0.9461746957575601,4.11241323902979,9.28607424982556,0.7853186642892772,2.92482105284911,7.377393713199281,10.86412931610028,3.730859641827872,7.10856486442072,8.633139365350852,2.29734265492637,10.13972845974508,9.710327586681363],null,null,{\"interactive\":true,\"className\":\"\",\"stroke\":true,\"color\":\"#03F\",\"weight\":5,\"opacity\":0.5,\"fill\":true,\"fillColor\":\"#03F\",\"fillOpacity\":0.2},null,null,null,null,null,{\"interactive\":false,\"permanent\":false,\"direction\":\"auto\",\"opacity\":1,\"offset\":[0,0],\"textsize\":\"10px\",\"textOnly\":false,\"className\":\"\",\"sticky\":true},null]}],\"limits\":{\"lat\":[50.9027638,51.3633619],\"lng\":[2.8073042,5.8282973]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n\nMap with the locations for tundra bean goose. The circle markers represent the centroid of the site. The area of the circle is proportional to the mean of the observed counts.\n:::\n:::\n\n\n# `INLA` vs `inlabru`\n\n## Fixed effects only\n\nLet's start with a very simple model with contains only the year centred to the last year.\nThe syntax of both models is very similar.\n[`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) is a bit shorted because it returns both $WAIC$ and $DIC$ by default.\nThe models are identical because [`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) is just a wrapper for `inla()`.\nTheir summary output is somewhat different in terms of lay-out and which information is given.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(INLA)\nlibrary(inlabru)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngoose |>\n  mutate(cyear = .data$year - max(.data$year)) -> goose\nm0_inla <- inla(\n  count ~ cyear,  data = goose,  family = \"nbinomial\",\n  control.compute = list(waic = TRUE, dic = TRUE)\n)\nm0_inlabru <- bru(count ~ cyear, data = goose, family = \"nbinomial\")\nsummary(m0_inla)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" keep = keep, working.directory = working.directory, \n   silent = silent, \", \" inla.mode = inla.mode, safe = FALSE, debug = \n   debug, .parent.frame = .parent.frame)\" ) \nTime used:\n    Pre = 0.431, Running = 0.682, Post = 0.0266, Total = 1.14 \nFixed effects:\n             mean    sd 0.025quant 0.5quant 0.975quant  mode kld\n(Intercept) 4.560 0.218      4.133    4.560      4.987 4.560   0\ncyear       0.134 0.026      0.083    0.134      0.185 0.134   0\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion) 0.047 0.003      0.043\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    0.047      0.053\n                                                        mode\nsize for the nbinomial observations (1/overdispersion) 0.047\n\nDeviance Information Criterion (DIC) ...............: 5913.61\nDeviance Information Criterion (DIC, saturated) ....: 823.50\nEffective number of parameters .....................: 2.92\n\nWatanabe-Akaike information criterion (WAIC) ...: 5914.06\nEffective number of parameters .................: 3.18\n\nMarginal log-Likelihood:  -3003.70 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n\n```{.r .cell-code}\nsummary(m0_inlabru)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.8.0\nINLA version: 23.06.29\nComponents:\ncyear: main = linear(cyear), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'nbinomial'\n    Data class: 'data.frame'\n    Predictor: count ~ .\nTime used:\n    Pre = 0.381, Running = 0.623, Post = 0.0499, Total = 1.05 \nFixed effects:\n           mean    sd 0.025quant 0.5quant 0.975quant  mode kld\ncyear     0.134 0.026      0.083    0.134      0.185 0.134   0\nIntercept 4.560 0.218      4.133    4.560      4.987 4.560   0\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion) 0.047 0.003      0.043\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    0.047      0.053\n                                                        mode\nsize for the nbinomial observations (1/overdispersion) 0.047\n\nDeviance Information Criterion (DIC) ...............: 5913.61\nDeviance Information Criterion (DIC, saturated) ....: 823.51\nEffective number of parameters .....................: 2.92\n\nWatanabe-Akaike information criterion (WAIC) ...: 5914.06\nEffective number of parameters .................: 3.18\n\nMarginal log-Likelihood:  -3008.08 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\n\n\nA drawback is that [`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) doesn't handle factor fixed effects.\nIn a previous version it yielded a warning about invalid factor levels when fitting the model.\nUnfortunately you didn't get the warning when getting the summary.\nYou needed to be critical and noticed that the parameters of the model are not what you would expect.\nThe current version throws a cryptic error.\nThe workaround is to convert the factor variable into a set of dummy variables and use those.\nCreating the dummy variable is straight forward with `model.matrix()`.\nBut adding them to the model is not very efficient when you have factor variables with more than a just few levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1_inla <- inla(\n  count ~ cyear + month, data = goose, family = \"nbinomial\",\n  control.compute = list(waic = TRUE, dic = TRUE)\n)\nm1_inlabru <- bru(count ~ cyear + month, data = goose, family = \"nbinomial\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in validObject(r): invalid class \"dgTMatrix\" object: 'x' slot is not of type \"double\"\n```\n:::\n\n```{.r .cell-code}\nsummary(m1_inla)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" keep = keep, working.directory = working.directory, \n   silent = silent, \", \" inla.mode = inla.mode, safe = FALSE, debug = \n   debug, .parent.frame = .parent.frame)\" ) \nTime used:\n    Pre = 0.336, Running = 0.528, Post = 0.0333, Total = 0.898 \nFixed effects:\n             mean    sd 0.025quant 0.5quant 0.975quant  mode kld\n(Intercept) 2.704 0.259      2.195    2.704      3.213 2.704   0\ncyear       0.177 0.026      0.127    0.177      0.227 0.177   0\nmonthdec    2.116 0.337      1.456    2.116      2.777 2.116   0\nmonthjan    2.760 0.343      2.087    2.760      3.434 2.760   0\nmonthfeb    2.353 0.332      1.703    2.353      3.003 2.353   0\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion) 0.051 0.003      0.046\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    0.051      0.057\n                                                        mode\nsize for the nbinomial observations (1/overdispersion) 0.051\n\nDeviance Information Criterion (DIC) ...............: 5870.18\nDeviance Information Criterion (DIC, saturated) ....: 827.87\nEffective number of parameters .....................: 5.86\n\nWatanabe-Akaike information criterion (WAIC) ...: 5871.70\nEffective number of parameters .................: 6.64\n\nMarginal log-Likelihood:  -2991.55 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n\n```{.r .cell-code}\ngoose |> \n  model.matrix(object = ~month) |>\n  as.data.frame() |>\n  select(-1) |>\n  bind_cols(goose) -> goose\nm1_inlabru <- bru(\n  count ~ cyear + monthdec + monthjan + monthfeb, data = goose,\n  family = \"nbinomial\"\n)\nsummary(m1_inlabru)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.8.0\nINLA version: 23.06.29\nComponents:\ncyear: main = linear(cyear), group = exchangeable(1L), replicate = iid(1L)\nmonthdec: main = linear(monthdec), group = exchangeable(1L), replicate = iid(1L)\nmonthjan: main = linear(monthjan), group = exchangeable(1L), replicate = iid(1L)\nmonthfeb: main = linear(monthfeb), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'nbinomial'\n    Data class: 'data.frame'\n    Predictor: count ~ .\nTime used:\n    Pre = 0.333, Running = 0.618, Post = 0.0444, Total = 0.996 \nFixed effects:\n           mean    sd 0.025quant 0.5quant 0.975quant  mode kld\ncyear     0.177 0.026      0.127    0.177      0.227 0.177   0\nmonthdec  2.117 0.337      1.456    2.117      2.777 2.117   0\nmonthjan  2.760 0.343      2.087    2.760      3.434 2.760   0\nmonthfeb  2.353 0.332      1.703    2.353      3.003 2.353   0\nIntercept 2.704 0.259      2.195    2.704      3.213 2.704   0\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion) 0.051 0.003      0.046\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    0.051      0.057\n                                                        mode\nsize for the nbinomial observations (1/overdispersion) 0.051\n\nDeviance Information Criterion (DIC) ...............: 5870.17\nDeviance Information Criterion (DIC, saturated) ....: 827.77\nEffective number of parameters .....................: 5.86\n\nWatanabe-Akaike information criterion (WAIC) ...: 5871.69\nEffective number of parameters .................: 6.64\n\nMarginal log-Likelihood:  -2995.93 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\n\n\n## Random effects\n\n`inla()` use the `f()` function to specify the random effects.\n[`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) is very liberal and allows the user to choose any name, as long as it is a valid function name.\nIn the example below we use `site`.\nFor more detail see `help(\"bru.components\")`.\nThe downside is that [`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) requires integer coded levels which go from 1 to the number of levels.\nWe use the `as.integer(factor())` trick to get these indices.\nFurthermore you need to supply the number of levels in the random effect for some random effects models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomp_inla <- count ~ cyear + month + f(location_id, model = \"iid\")\nm2_inla <- inla(\n  comp_inla, data = goose, family = \"nbinomial\",\n  control.compute = list(waic = TRUE, dic = TRUE)\n)\ngoose |>\n  mutate(\n    loc_id = factor(.data$location_id) |>\n      as.integer()\n  ) -> goose\nn_loc <- max(goose$loc_id)\ncomp_inlabru <- count ~ cyear + monthdec + monthjan + monthfeb + \n  site(main = loc_id, model = \"iid\", n = n_loc)\nm2_inlabru <- bru(comp_inlabru, data = goose, family = \"nbinomial\")\nsummary(m2_inla)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n   c(\"inla.core(formula = formula, family = family, contrasts = contrasts, \n   \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \" \n   scale = scale, weights = weights, Ntrials = Ntrials, strata = strata, \n   \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose = \n   verbose, \", \" lincomb = lincomb, selection = selection, control.compute \n   = control.compute, \", \" control.predictor = control.predictor, \n   control.family = control.family, \", \" control.inla = control.inla, \n   control.fixed = control.fixed, \", \" control.mode = control.mode, \n   control.expert = control.expert, \", \" control.hazard = control.hazard, \n   control.lincomb = control.lincomb, \", \" control.update = \n   control.update, control.lp.scale = control.lp.scale, \", \" \n   control.pardiso = control.pardiso, only.hyperparam = only.hyperparam, \n   \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads = \n   num.threads, \", \" keep = keep, working.directory = working.directory, \n   silent = silent, \", \" inla.mode = inla.mode, safe = FALSE, debug = \n   debug, .parent.frame = .parent.frame)\" ) \nTime used:\n    Pre = 0.366, Running = 1.42, Post = 0.0391, Total = 1.82 \nFixed effects:\n             mean    sd 0.025quant 0.5quant 0.975quant  mode kld\n(Intercept) 1.884 0.414      1.070    1.884      2.697 1.884   0\ncyear       0.178 0.029      0.121    0.178      0.235 0.178   0\nmonthdec    1.690 0.353      0.996    1.690      2.383 1.690   0\nmonthjan    2.588 0.345      1.911    2.587      3.264 2.587   0\nmonthfeb    2.497 0.335      1.840    2.497      3.155 2.497   0\n\nRandom effects:\n  Name\t  Model\n    location_id IID model\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion) 0.064 0.004      0.057\nPrecision for location_id                              0.428 0.137      0.218\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    0.064      0.072\nPrecision for location_id                                 0.409      0.751\n                                                        mode\nsize for the nbinomial observations (1/overdispersion) 0.064\nPrecision for location_id                              0.372\n\nDeviance Information Criterion (DIC) ...............: 5747.04\nDeviance Information Criterion (DIC, saturated) ....: 855.13\nEffective number of parameters .....................: 27.50\n\nWatanabe-Akaike information criterion (WAIC) ...: 5753.22\nEffective number of parameters .................: 26.72\n\nMarginal log-Likelihood:  -2955.36 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n\n```{.r .cell-code}\nsummary(m2_inlabru)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.8.0\nINLA version: 23.06.29\nComponents:\ncyear: main = linear(cyear), group = exchangeable(1L), replicate = iid(1L)\nmonthdec: main = linear(monthdec), group = exchangeable(1L), replicate = iid(1L)\nmonthjan: main = linear(monthjan), group = exchangeable(1L), replicate = iid(1L)\nmonthfeb: main = linear(monthfeb), group = exchangeable(1L), replicate = iid(1L)\nsite: main = iid(loc_id), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'nbinomial'\n    Data class: 'data.frame'\n    Predictor: count ~ .\nTime used:\n    Pre = 0.333, Running = 0.674, Post = 0.115, Total = 1.12 \nFixed effects:\n           mean    sd 0.025quant 0.5quant 0.975quant  mode kld\ncyear     0.178 0.029      0.121    0.178      0.235 0.178   0\nmonthdec  1.690 0.354      0.996    1.690      2.383 1.690   0\nmonthjan  2.588 0.345      1.911    2.588      3.264 2.588   0\nmonthfeb  2.497 0.335      1.840    2.497      3.155 2.497   0\nIntercept 1.884 0.414      1.069    1.884      2.697 1.884   0\n\nRandom effects:\n  Name\t  Model\n    site IID model\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion) 0.064 0.004      0.057\nPrecision for site                                     0.428 0.137      0.218\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    0.064      0.072\nPrecision for site                                        0.408      0.753\n                                                        mode\nsize for the nbinomial observations (1/overdispersion) 0.064\nPrecision for site                                     0.372\n\nDeviance Information Criterion (DIC) ...............: 5747.03\nDeviance Information Criterion (DIC, saturated) ....: 854.97\nEffective number of parameters .....................: 27.50\n\nWatanabe-Akaike information criterion (WAIC) ...: 5753.21\nEffective number of parameters .................: 26.73\n\nMarginal log-Likelihood:  -2959.73 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\n\n\nThe use of user defined names for random effect functions has the benefit that you can use the same variable multiple times in the model.\n`inla()` requires unique names and hence copies of the variable.\nThe `main` argument also allows to use a function of a variable, thus removing the need of creating a new variable.\nThe `model = \"linear\"` is another way of specifying a continuous fixed effect.\nSee http://www.r-inla.org/models/latent-models for an overview of all available latent models in INLA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngoose |>\n  mutate(\n    cyear = .data$cyear - min(.data$cyear) + 1,\n    cyear2 = .data$cyear\n  ) -> goose2\nn_year <- max(goose2$cyear)\ncomp_inla <- count ~ cyear + f(cyear2, model = \"iid\") + \n  month + f(location_id, model = \"iid\")\nm3_inla <- inla(\n  comp_inla, data = goose2, family = \"nbinomial\", \n  control.compute = list(waic = TRUE, dic = TRUE)\n)\ncomp_inlabru <- count ~ cyear + monthdec + monthjan + monthfeb +\n  rtrend(main = cyear, model = \"iid\", n = n_year) +\n  site(main = loc_id, model = \"iid\", n = n_loc)\nm3_inlabru <- bru(comp_inlabru, data = goose2, family = \"nbinomial\")\ncomp_inlabru <- count ~ \n  lintrend(main = cyear, model = \"linear\") + \n  quadtrend(main = cyear ^ 2, model = \"linear\") +\n  rtrend(main = cyear, model = \"iid\", n = n_year) +\n  monthdec + monthjan + monthfeb + site(main = loc_id, model = \"iid\", n = n_loc)\nm3_inlabru2 <- bru(comp_inlabru, data = goose2, family = \"nbinomial\")\nsummary(m3_inlabru2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninlabru version: 2.8.0\nINLA version: 23.06.29\nComponents:\nlintrend: main = linear(cyear), group = exchangeable(1L), replicate = iid(1L)\nquadtrend: main = linear(cyear^2), group = exchangeable(1L), replicate = iid(1L)\nrtrend: main = iid(cyear), group = exchangeable(1L), replicate = iid(1L)\nmonthdec: main = linear(monthdec), group = exchangeable(1L), replicate = iid(1L)\nmonthjan: main = linear(monthjan), group = exchangeable(1L), replicate = iid(1L)\nmonthfeb: main = linear(monthfeb), group = exchangeable(1L), replicate = iid(1L)\nsite: main = iid(loc_id), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'nbinomial'\n    Data class: 'data.frame'\n    Predictor: count ~ .\nTime used:\n    Pre = 0.382, Running = 1.09, Post = 0.0649, Total = 1.54 \nFixed effects:\n            mean    sd 0.025quant 0.5quant 0.975quant   mode kld\nlintrend  -0.057 0.124     -0.301   -0.057      0.186 -0.057   0\nquadtrend  0.012 0.007     -0.001    0.012      0.026  0.012   0\nmonthdec   1.729 0.357      1.029    1.729      2.428  1.729   0\nmonthjan   2.630 0.348      1.947    2.630      3.312  2.630   0\nmonthfeb   2.573 0.337      1.913    2.573      3.234  2.573   0\nIntercept -0.237 0.636     -1.485   -0.237      1.011 -0.237   0\n\nRandom effects:\n  Name\t  Model\n    rtrend IID model\n   site IID model\n\nModel hyperparameters:\n                                                           mean       sd\nsize for the nbinomial observations (1/overdispersion) 6.40e-02 4.00e-03\nPrecision for rtrend                                   2.09e+04 2.20e+04\nPrecision for site                                     4.22e-01 1.34e-01\n                                                       0.025quant 0.5quant\nsize for the nbinomial observations (1/overdispersion)      0.057 6.40e-02\nPrecision for rtrend                                     1489.013 1.40e+04\nPrecision for site                                          0.218 4.01e-01\n                                                       0.975quant     mode\nsize for the nbinomial observations (1/overdispersion)   7.20e-02    0.064\nPrecision for rtrend                                     7.91e+04 4138.690\nPrecision for site                                       7.42e-01    0.364\n\nDeviance Information Criterion (DIC) ...............: 5749.41\nDeviance Information Criterion (DIC, saturated) ....: 860.43\nEffective number of parameters .....................: 31.28\n\nWatanabe-Akaike information criterion (WAIC) ...: 5759.08\nEffective number of parameters .................: 32.11\n\nMarginal log-Likelihood:  -2966.33 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n```\n:::\n:::\n\n\n## Meshed random effects\n\nOne of the great benefits of `inlabru` is that it makes it much easier to work with random effects on a mesh.\nThe current data are geographic coordinates in \"WGS84\".\nFor this analysis we want them in a projected coordinate system. \"Belgian Lambert 72\" [EPSG:31370](https://epsg.io/31370) is a relevant choice.\nTherefore we convert the data into a `SpatialPointsDataFrame` and transform it to EPSG:31370.\n\nInstead of using a convex hull of the locations, we will use the administrative borders of [Flanders](https://en.wikipedia.org/wiki/Flanders) as a boundary for the mesh.\nThe simplified version of this border is the blue line in @fig-flanders-mesh.\nNote that the mesh extents this border because that reduces potential edge effects.\nThe detail of the mesh is defined by `cutoff` and `max.edge`, the former defines the minimal length of each edge and the latter the maximal length.\nThese lengths have the same units as the coordinate system, in this case meters.\nWe pass two numbers for both arguments.\nThe first refers to the edges inside the boundary, the second to edges outside the boundary.\nThis creates larger triangles outside the boundary, which will speed up the computation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_as_sf(goose, coords = c(\"long\", \"lat\"), crs = st_crs(4326)) |>\n  st_transform(st_crs(31370)) -> goose_lambert\nread_sf(\"data/vlaanderen.shp\") -> flanders\nas.inla.mesh.segment(flanders) -> flanders_segment\ninla.mesh.2d(\n  boundary = flanders_segment, max.edge = c(10e3, 20e3), cutoff = c(5e3, 10e3)\n) -> flanders_mesh\nggplot() +\n  gg(flanders_mesh) +\n  geom_sf(data = goose_lambert, col = \"red\") +\n  coord_sf()\n```\n\n::: {.cell-output-display}\n![Mesh for Flanders. Red circles indicate the sites.,](inlabru_files/figure-html/fig-flanders-mesh-1.svg){#fig-flanders-mesh width=672}\n:::\n:::\n\n\nOnce the mesh is defined, we can create the [stochastic partial differential equation](https://en.wikipedia.org/wiki/Stochastic_partial_differential_equation) SPDE model.\nIn this case we define it using a [Matérn covariance function](https://en.wikipedia.org/wiki/Mat%C3%A9rn_covariance_function).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflanders_spde <- inla.spde2.pcmatern(\n  flanders_mesh, prior.range = c(1e3, 0.99), prior.sigma = c(4, 0.01)\n)\n```\n:::\n\n\nAll steps up to this point are needed for both `INLA::inla()` and [`inlabr::bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html).\nIn case of `INLA::inla()` you need use `inla.spde.make.A()` to define a project matrix.\nThis matrix maps the coordinates of the observation to the three nodes of the triangle in which it is located.\nIn the special case that the observation is on a edge it will map to the two nodes defining the edge, or the node itself in case the observation coincides with a node.\nThen you need to define a `inla.stack()`, which is passed to the `data` argument after transforming it with `inla.stack.data()`.\nThe SPDE object is used as `model` in the random effect \"site\".\n\nThe same model is much easier with  [`inlabr::bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html).\nIn this case you need to pass a `SpatialPointsDataFrame` to the `data` argument.\nThe random effect \"site\" has the SPDE object as `model` and uses \"coordinates\" as `main`.\nIn this case there is no object \"coordinates\" in the data, hence `inlabr::bru()` will look in the environment and finds the `sf::st_coordinates()` function.\nThis functions returns the coordinates of an `sf` object, so [`inlabr::bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html) has all the information it needs to map the observations to the SPDE object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## INLA\nA <- inla.spde.make.A(mesh = flanders_mesh, loc = goose_lambert)\ngoose_stack <- inla.stack(\n  tag = 'estimation', ## tag\n  data = list(count = goose$count), ## response\n  A = list(A, 1), ## two projector matrices (SPDE and fixed effects)\n  effects = list(## two elements:\n    site = seq_len(flanders_spde$n.spde), ## RF index\n    goose |>\n      select(\"cyear\", \"month\")\n  )\n)\ncomp_inla <- count ~ 0 + month + cyear + f(site, model = flanders_spde)\nm4_inla <- inla(\n  comp_inla, data = inla.stack.data(goose_stack), family = \"nbinomial\", \n  control.compute = list(waic = TRUE, dic = TRUE),\n  control.predictor = list(A = inla.stack.A(goose_stack))\n)\n\n# inlabru\ncomp_inlabru <- count ~ monthdec + monthjan + monthfeb + cyear +\n  site(main = st_coordinates, model = flanders_spde)\nm4_inlabru <- bru(comp_inlabru, data = goose_lambert, family = \"nbinomial\")\n```\n:::\n\n\nWe can also create 1 dimensional meshes.\nThis is useful for line transects or (irregular) time series.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrend_mesh <- inla.mesh.1d(min(goose$year):max(goose$year), boundary = \"free\")\ntrend_spde <- inla.spde2.pcmatern(\n  trend_mesh, prior.range = c(1, 0.5), prior.sigma = c(4, 0.01)\n)\ncomp_inlabru <- count ~ monthdec + monthjan + monthfeb +\n  trend(main = year, model = trend_spde) +\n  site(main = st_coordinates, model = flanders_spde)\nm4b_inlabru <- bru(comp_inlabru, data = goose_lambert, family = \"nbinomial\")\n```\n:::\n\n\n## Plotting the model\n\n`plot.inla()` is an easy way to generate most of the relevant plots with a single command.\nIt will open several plot windows to keep the plots readable.\nHowever this doesn't work well in combination with Rmarkdown.\n`plot.bru()` has the opposite philosophy: you get the plot of only one component.\nGetting a plot for all components is a bit more tedious, but the advantage is that you can use it in combination with Rmarkdown.\nAnother nice feature is that `plot.bru()` returns `ggplot2` object.\nSo they are easy to adapt, see e.g. @fig-plot-fixed.\n`inlabru` also provides a `multiplot()` function which can be used to combine several plots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npc_prior <- list(theta = list(prior = \"pc.prec\", param = c(1, 0.01)))\ngoose |>\n  mutate(iyear = .data$cyear - min(.data$cyear) + 1) -> goose\nn_year <- max(goose$iyear)\ncomp_inla <- count ~ month + \n  f(cyear, model = \"rw1\", hyper = pc_prior) + \n  f(location_id, model = \"iid\", hyper = pc_prior)\nm5_inla <- inla(\n  comp_inla, data = goose, family = \"nbinomial\", \n  control.compute = list(waic = TRUE, dic = TRUE)\n)\ncomp_inlabru <- count ~ monthdec + monthjan + monthfeb + \n  trend(main = iyear, model = \"rw1\", n = n_year, hyper = pc_prior) +\n  site(main = loc_id, model = \"iid\", n = n_loc, hyper = pc_prior)\nm5_inlabru <- bru(comp_inlabru, data = goose, family = \"nbinomial\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(m5_inla)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np_intercept <- plot(m5_inlabru, \"Intercept\") + \n  geom_vline(xintercept = 0, linetype = 2) +\n  xlim(-1, 4)\np_monthdec <- plot(m5_inlabru, \"monthdec\") + \n  geom_vline(xintercept = 0, linetype = 2) +\n  xlim(-1, 4)\np_monthjan <- plot(m5_inlabru, \"monthjan\") + \n  geom_vline(xintercept = 0, linetype = 2) +\n  xlim(-1, 4)\np_monthfeb <- plot(m5_inlabru, \"monthfeb\") + \n  geom_vline(xintercept = 0, linetype = 2) +\n  xlim(-1, 4)\nmultiplot(p_intercept, p_monthdec, p_monthjan, p_monthfeb)\n```\n\n::: {.cell-output-display}\n![Posterior density plots of the fixed effects](inlabru_files/figure-html/fig-plot-fixed-1.svg){#fig-plot-fixed width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(m5_inlabru, \"trend\")\n```\n\n::: {.cell-output-display}\n![Posterior density of the trend random intercepts.](inlabru_files/figure-html/fit-plot-trend-1.svg){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(m5_inlabru, \"site\")\n```\n\n::: {.cell-output-display}\n![Posterior density of the site random intercepts.\"](inlabru_files/figure-html/fig-site-1.svg){#fig-site width=672}\n:::\n:::\n\n\n### Plotting meshes\n\nThe mesh effects can be plot in a similar way.\nThe default plot will display the estimate effect at each node.\nWhile this can be useful for 1D plot with a small number of nodes (top of @fig-mesh-plot), this is not useful for 2D meshes or meshed with a large number of nodes (bottom of @fig-mesh-plot).\nLooking at the posterior distributions for the range and the variance of the Matérn covariance structure of SPDE model makes more sense [@fig-mesh-range-var].\nOr plot the actual Matérn functions [@fig-matern-function].\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_trend <- plot(m4b_inlabru, \"trend\")\np_site <- plot(m4b_inlabru, \"site\")\nmultiplot(p_trend, p_site)\n```\n\n::: {.cell-output-display}\n![Posterior density of the random intercepts at the nodes of the mesh.](inlabru_files/figure-html/fig-mesh-plot-1.svg){#fig-mesh-plot width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspde_range <- spde.posterior(m4b_inlabru, \"site\", what = \"range\")\nspde_logvar <- spde.posterior(m4b_inlabru, \"site\", what = \"log.variance\")\nrange_plot <- plot(spde_range)\nvar_plot <- plot(spde_logvar)\nmultiplot(range_plot, var_plot)\n```\n\n::: {.cell-output-display}\n![Posterior distributions of the range and log variance of the Matérn covariace for the sites.](inlabru_files/figure-html/fig-mesh-range-var-1.svg){#fig-mesh-range-var width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspde.posterior(m4b_inlabru, \"site\", what = \"matern.covariance\") |>\n  plot() +\n  xlab(\"distance\") +\n  ylab(\"covariance\") -> covplot\nspde.posterior(m4b_inlabru, \"site\", what = \"matern.correlation\") |>\n  plot()  +\n  xlab(\"distance\") +\n  ylab(\"correlation\") -> corplot\nmultiplot(covplot, corplot)\n```\n\n::: {.cell-output-display}\n![Fitted Matérn covariance and correlation functions.](inlabru_files/figure-html/fig-matern-function-1.svg){#fig-matern-function width=672}\n:::\n:::\n\n\n# Predictions\n\n`INLA` has, unlike most R packages, no `predict()` function.\nSo `INLA` can't do predictions? No, it can do prediction but it does that simultaneously with fitting the model.\nThis implies that you need to add the observations for which you want prediction to the data prior to the model fitting.\nSetting the response variable to `NA` avoid that these observation influence the model parameters.\nA huge downside of this is, that you need to plan ahead and carefully prepare your data.\nIf you forget some prediction, you will have to fit the model again. \n\nThe `predict()` function in most R packages split the model fitting and the prediction in two separate steps.\nGetting prediction for another data set does not require to refit the model.\n`inlabru` provided a `predict()` function for [`bru()`](https://inlabru-org.github.io/inlabru/reference/bru.html),\n[`lgcp()`](https://inlabru-org.github.io/inlabru/reference/lgcp.html) and `inla` models.\nThe fitting works slightly different in `INLA` and `inlabru`.\nWhen the observations for the prediction are available at the time of the model fitting, then the full posterior of those observations becomes available.\n`inlabru::predict.inla()` works by repeatedly sampling the posterior distributions of the parameters and use each sample to calculate a predicted values.\nThis yields a sampled posterior distribution for the fitted value of the observations.\n\n`predict.bru()` requires at least three arguments: `object` the fitted model; `data` the new observations for which you want a prediction and `formula` the components of the model you want to use in the predictions.\nThe example below calculates the predictions for only the trend component.\nNote that the predict function returns the `data` and adds several columns with relevant information on the prediction.\nThe names of these columns are more efficient than those returned by `INLA`: `q0.025` is a valid name for an R object, whereas `0.025quant` isn't.\nAnother nice feather is that you can incorporate the prediction directly into a `ggplot2` plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngoose |>\n  distinct(.data$year, .data$iyear) |>\n  predict(object = m5_inlabru, formula = ~ trend) -> pred_trend_log\n# predictions from inlabru\nglimpse(pred_trend_log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 16\nColumns: 10\n$ year            <int> 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, …\n$ iyear           <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\n$ mean            <dbl> -1.26492328, -1.10300657, -0.64025785, -0.04384605, -0…\n$ sd              <dbl> 0.4354434, 0.3897294, 0.3059353, 0.2804278, 0.3514885,…\n$ q0.025          <dbl> -2.1474854, -1.7576974, -1.2092356, -0.5072800, -0.918…\n$ q0.5            <dbl> -1.28189855, -1.12406431, -0.66454915, -0.06854624, -0…\n$ q0.975          <dbl> -0.48339034, -0.30069626, -0.06429868, 0.56756712, 0.3…\n$ median          <dbl> -1.28189855, -1.12406431, -0.66454915, -0.06854624, -0…\n$ mean.mc_std_err <dbl> 0.04354434, 0.03897294, 0.03059353, 0.02804278, 0.0351…\n$ sd.mc_std_err   <dbl> 0.03406361, 0.02467601, 0.02089418, 0.02216102, 0.0303…\n```\n:::\n\n```{.r .cell-code}\n# fitted value from INLA\nglimpse(m5_inla$summary.fitted.values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,502\nColumns: 6\n$ mean         <dbl> 0.32819463, 0.02660591, 0.44608849, 0.38387280, 0.3644789…\n$ sd           <dbl> 0.28142516, 0.02772871, 0.32342400, 0.34817990, 0.3259733…\n$ `0.025quant` <dbl> 0.056964563, 0.003466924, 0.099872163, 0.059385902, 0.058…\n$ `0.5quant`   <dbl> 0.24913115, 0.01843897, 0.36136136, 0.28430870, 0.2716765…\n$ `0.975quant` <dbl> 1.06895178, 0.09885806, 1.29134639, 1.30084367, 1.2225001…\n$ mode         <dbl> 0.142676245, 0.008920501, 0.236785766, 0.153485444, 0.149…\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  gg(pred_trend_log) +\n  geom_hline(yintercept = 0, linetype = 2)\n```\n\n::: {.cell-output-display}\n![Predicted effect of `trend` on the link scale.](inlabru_files/figure-html/fig-trend-prediction-1.svg){#fig-trend-prediction width=672}\n:::\n:::\n\n\nThe default prediction are on the link scale, which is the log link in this case.\nBack-transformation is straightforward, just add the back transformation function to the formula.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngoose |>\n  distinct(.data$year, .data$iyear) |>\n  predict(object = m5_inlabru, formula = ~ exp(trend)) -> pred_trend_natural\nggplot() +\n  gg(pred_trend_natural) +\n  geom_hline(yintercept = 1, linetype = 2)\n```\n\n::: {.cell-output-display}\n![Predicted effect of 'trend' on the natural scale](inlabru_files/figure-html/fig-trend-prediction-natural-1.svg){#fig-trend-prediction-natural width=672}\n:::\n:::\n\n\nThe `gg()` solutions works only in case of a single covariate.\nWith multiple covariate you have to create the plot manually.\nBut that is not very hard given the nice format of the output returned by `predict.bru()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngoose |>\n  distinct(\n    .data$year, .data$month, .data$iyear, .data$monthdec, .data$monthjan,\n    .data$monthfeb\n  ) |>\n  predict(\n    object = m5_inlabru, \n    formula = ~ exp(Intercept + trend + monthdec + monthjan + monthfeb)\n  ) -> pred_trend_month\nggplot(pred_trend_month, aes(x = year, y = mean, ymin = q0.025, ymax = q0.975)) +\n  geom_ribbon(aes(fill = month), alpha = 0.1) +\n  geom_line(aes(colour = month))\n```\n\n::: {.cell-output-display}\n![Predicted average expected mean of the counts.](inlabru_files/figure-html/fig-prediction-average-1.svg){#fig-prediction-average width=672}\n:::\n:::\n\n\nAnother very neat feature is that you can take both the model uncertainty as the natural variability into account.\nThe model estimates the mean of the negative binomial distribution.\nThe variability of this mean only includes the model uncertainty.\nIn case we are interested in the total variability in the count, we need to plug this mean into the distribution.\nBelow is an example on how to do this.\nAFAIK this works only for a single prediction.\nThe result yields the distribution of the counts.\n`inla.zmarginal` is used to calculate the mean and the quantiles of this distribution.\nPlease note that is not entirely correct as we are ignoring the variability of the dispersion parameter of the negative binomial distribution.\nI'm not sure how to incorporate that at the moment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsize <- 1 / m5_inlabru$summary.hyperpar[1, \"mean\"]\ngoose |>\n  distinct(.data$year, .data$iyear, .data$month, .data$monthjan) |>\n  filter(.data$year == max(.data$year), .data$month == \"jan\") |>\n  predict(\n    object = m5_inlabru, \n    formula =   ~ data.frame(\n      n = 0:450,\n      dnbinom(0:450, size = size, mu = exp(Intercept + trend + monthjan))\n    ),\n    n.samples = 1e2\n  ) -> pred_trend_natural_n\npred_trend_natural_n |>\n  select(x = \"n\", y = \"mean\") |>\n  as.list() |>\n  inla.zmarginal(silent = TRUE) |>\n  unlist() -> quants\nggplot(pred_trend_natural_n, aes(x = n, y = mean)) +\n  geom_line() +\n  geom_vline(\n    xintercept = quants[c(\"mean\", \"quant0.025\", \"quant0.975\")],\n    linetype = 2\n  )\n```\n\n::: {.cell-output-display}\n![Distribution of the average counts for the last year in January. Dashed lines indicate the mean, 2.5% and 97.5% quantiles.](inlabru_files/figure-html/fig-distn-1.svg){#fig-distn width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngoose |>\n  distinct(.data$year, .data$iyear, .data$month, .data$monthjan) |>\n  filter(.data$year == max(.data$year), .data$month == \"jan\") |>\n  predict(\n    object = m5_inlabru, \n    formula =   ~ data.frame(\n      n = 0:450,\n      dnbinom(0:450, size = size, mu = exp(Intercept + trend + monthjan))\n    ),\n    n.samples = 1e3\n  ) -> pred_trend_natural_n2\npred_trend_natural_n2 |>\n  select(x = n, y = mean) |>\n  as.list() |>\n  inla.zmarginal(silent = TRUE) |>\n  unlist() -> quants2\nggplot(pred_trend_natural_n, aes(x = n, y = mean)) +\n  geom_line() +\n  geom_line(data = pred_trend_natural_n2, colour = \"red\") +\n  geom_vline(\n    xintercept = quants[c(\"mean\", \"quant0.025\", \"quant0.975\")], linetype = 2\n  ) +\n  geom_vline(\n    xintercept = quants2[c(\"mean\", \"quant0.025\", \"quant0.975\")], linetype = 2,\n    colour = \"red\"\n  )\n```\n\n::: {.cell-output-display}\n![Distribution of the average counts for the last year in January. Dashed lines indicate the mean, 2.5% and 97.5% quantiles. Black lines are based on 100 samples, red lines on 1000 samples.](inlabru_files/figure-html/fig-distn2-1.svg){#fig-distn2 width=672}\n:::\n:::\n\n\nWe can also use aggregations in the formula.\nLet's say we want to estimate the total number of birds over all sites at a given year and month.\nThe example below illustrated how you can use aggregation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# total of expected counts\ngoose |>\n  filter(.data$year == max(.data$year), .data$month == \"jan\") |>\n  predict(\n    object = m5_inlabru, \n    formula = ~ exp(\n      Intercept + trend + monthdec + monthjan + monthfeb + site\n    ) |>\n        sum()\n  ) -> pred_total\nglimpse(pred_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1\nColumns: 8\n$ mean            <dbl> 10351.9\n$ sd              <dbl> 5940.449\n$ q0.025          <dbl> 3109.634\n$ q0.5            <dbl> 8915.001\n$ q0.975          <dbl> 25892.04\n$ median          <dbl> 8915.001\n$ mean.mc_std_err <dbl> 594.0449\n$ sd.mc_std_err   <dbl> 662.9453\n```\n:::\n\n```{.r .cell-code}\n# distribution of total counts\nlow <- qnbinom(0.001, mu = pred_total$q0.025, size = size)\nhigh <- qnbinom(0.999, mu = pred_total$q0.975, size = size)\ngoose |>\n  filter(.data$year == max(.data$year), .data$month == \"jan\") |>\n  predict(\n    object = m5_inlabru, \n    formula =   ~ data.frame(\n      n = low:high,\n      dnbinom(\n        low:high, size = size,\n        mu = exp(Intercept + trend + monthdec + monthjan + monthfeb + site) |>\n          sum()\n      )\n    )\n  ) -> pred_total_natural\npred_total_natural |>\n  select(x = \"n\", y = \"mean\") |>\n  as.list() |>\n  inla.zmarginal(silent = TRUE) |>\n  unlist() -> quants\nggplot(pred_total_natural, aes(x = n, y = mean)) +\n  geom_line() +\n  geom_vline(\n    xintercept = quants[c(\"mean\", \"quant0.025\", \"quant0.975\")],\n    linetype = 2\n  )\n```\n\n::: {.cell-output-display}\n![Distribution of the total counts for the last year in January. Dashed lines indicate the mean, 2.5% and 97.5% quantiles.](inlabru_files/figure-html/fig-distn3-1.svg){#fig-distn3 width=672}\n:::\n:::\n\n\nWe can make predictions for the mesh as well. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_mesh <- predict(\n  m4b_inlabru, fm_pixels(flanders_mesh, nx = 80, ny = 30), ~exp(site)\n)\nst_crs(pred_mesh) <- 31370\nsite_mean <- ggplot() +\n  geom_sf(data = pred_mesh, aes(colour = median)) +\n  geom_sf(data = flanders, fill = NA, colour = \"red\", linewidth = 0.5)\nsite_q0.025 <- ggplot() +\n  geom_sf(data = pred_mesh, aes(colour = q0.025)) +\n  geom_sf(data = flanders, fill = NA, colour = \"red\", linewidth = 0.5)\nsite_q0.975 <- ggplot() +\n  geom_sf(data = pred_mesh, aes(colour = q0.975)) +\n  geom_sf(data = flanders, fill = NA, colour = \"red\", linewidth = 0.5)\nsite_cv <- ggplot() +\n  geom_sf(data = pred_mesh, aes(colour = sd)) +\n  geom_sf(data = flanders, fill = NA, colour = \"red\", linewidth = 0.5)\nmultiplot(site_mean, site_q0.025, site_cv, site_q0.975, cols = 2)\n```\n\n::: {.cell-output-display}\n![Relative effect of the spatial field of the sites.](inlabru_files/figure-html/fig-prediction-mesh-1.svg){#fig-prediction-mesh width=672}\n:::\n:::\n\n\n## Session info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language nl_BE:nl\n collate  nl_BE.UTF-8\n ctype    nl_BE.UTF-8\n tz       Europe/Brussels\n date     2023-08-30\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version    date (UTC) lib source\n class          7.3-22     2023-05-03 [4] CRAN (R 4.3.1)\n classInt       0.4-9      2023-02-28 [1] CRAN (R 4.3.1)\n cli            3.6.1      2023-03-23 [1] CRAN (R 4.3.0)\n colorspace     2.1-0      2023-01-23 [1] CRAN (R 4.3.0)\n crosstalk      1.2.0      2021-11-04 [1] CRAN (R 4.3.0)\n DBI            1.1.3      2022-06-18 [1] CRAN (R 4.3.0)\n digest         0.6.32     2023-06-26 [1] CRAN (R 4.3.1)\n dplyr        * 1.1.2      2023-04-20 [1] CRAN (R 4.3.0)\n e1071          1.7-13     2023-02-01 [1] CRAN (R 4.3.1)\n ellipsis       0.3.2      2021-04-29 [1] CRAN (R 4.3.0)\n evaluate       0.21       2023-05-05 [1] CRAN (R 4.3.0)\n fansi          1.0.4      2023-01-22 [1] CRAN (R 4.3.0)\n farver         2.1.1      2022-07-06 [1] CRAN (R 4.3.0)\n fastmap        1.1.1      2023-02-24 [1] CRAN (R 4.3.0)\n forcats      * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n generics       0.1.3      2022-07-05 [1] CRAN (R 4.3.0)\n ggplot2      * 3.4.2      2023-04-03 [1] CRAN (R 4.3.0)\n glue           1.6.2      2022-02-24 [1] CRAN (R 4.3.0)\n gtable         0.3.3      2023-03-21 [1] CRAN (R 4.3.0)\n hms            1.1.3      2023-03-21 [1] CRAN (R 4.3.0)\n htmltools      0.5.5      2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets    1.6.2      2023-03-17 [1] CRAN (R 4.3.0)\n INLA         * 23.06.29   2023-06-30 [1] local\n inlabru      * 2.8.0      2023-06-20 [1] CRAN (R 4.3.1)\n jsonlite       1.8.7      2023-06-29 [1] CRAN (R 4.3.1)\n KernSmooth     2.23-21    2023-05-03 [1] CRAN (R 4.3.0)\n knitr          1.43       2023-05-25 [1] CRAN (R 4.3.0)\n labeling       0.4.2      2020-10-20 [1] CRAN (R 4.3.0)\n lattice        0.21-8     2023-04-05 [4] CRAN (R 4.3.0)\n leaflet      * 2.1.2      2023-03-10 [1] CRAN (R 4.3.0)\n lifecycle      1.0.3      2022-10-07 [1] CRAN (R 4.3.0)\n lubridate    * 1.9.2.9000 2023-05-15 [1] https://inbo.r-universe.dev (R 4.3.0)\n magrittr       2.0.3      2022-03-30 [1] CRAN (R 4.3.0)\n Matrix       * 1.5-4.1    2023-05-18 [1] CRAN (R 4.3.0)\n MatrixModels   0.5-1      2022-09-11 [1] CRAN (R 4.3.0)\n mnormt         2.1.1      2022-09-26 [1] CRAN (R 4.3.0)\n munsell        0.5.0      2018-06-12 [1] CRAN (R 4.3.0)\n numDeriv       2016.8-1.1 2019-06-06 [1] CRAN (R 4.3.0)\n pillar         1.9.0      2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig      2.0.3      2019-09-22 [1] CRAN (R 4.3.0)\n plyr           1.8.8      2022-11-11 [1] CRAN (R 4.3.0)\n proxy          0.4-27     2022-06-09 [1] CRAN (R 4.3.1)\n purrr        * 1.0.1      2023-01-10 [1] CRAN (R 4.3.0)\n R6             2.5.1      2021-08-19 [1] CRAN (R 4.3.0)\n Rcpp           1.0.10     2023-01-22 [1] CRAN (R 4.3.0)\n readr        * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n rlang          1.1.1      2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown      2.23       2023-07-01 [1] CRAN (R 4.3.1)\n rstudioapi     0.14       2022-08-22 [1] CRAN (R 4.3.0)\n scales       * 1.2.1      2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo    1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n sf           * 1.0-13     2023-05-24 [1] CRAN (R 4.3.0)\n sn             2.1.1      2023-04-04 [1] CRAN (R 4.3.1)\n sp           * 2.0-0      2023-06-22 [1] CRAN (R 4.3.1)\n stringi        1.7.12     2023-01-11 [1] CRAN (R 4.3.0)\n stringr      * 1.5.0      2022-12-02 [1] CRAN (R 4.3.0)\n tibble       * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidyr        * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect     1.2.0      2022-10-10 [1] CRAN (R 4.3.0)\n tidyverse    * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n timechange     0.2.0      2023-01-11 [1] CRAN (R 4.3.0)\n tzdb           0.4.0      2023-05-12 [1] CRAN (R 4.3.0)\n units          0.8-2      2023-04-27 [1] CRAN (R 4.3.0)\n utf8           1.2.3      2023-01-31 [1] CRAN (R 4.3.0)\n vctrs          0.6.3      2023-06-14 [1] CRAN (R 4.3.0)\n withr          2.5.0      2022-03-03 [1] CRAN (R 4.3.0)\n xfun           0.39       2023-04-20 [1] CRAN (R 4.3.0)\n yaml           2.3.7      2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /home/thierry/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n",
    "supporting": [
      "inlabru_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\n<script src=\"../site_libs/jquery-1.12.4/jquery.min.js\"></script>\n<link href=\"../site_libs/leaflet-1.3.1/leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/leaflet-1.3.1/leaflet.js\"></script>\n<link href=\"../site_libs/leafletfix-1.0.0/leafletfix.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/proj4-2.6.2/proj4.min.js\"></script>\n<script src=\"../site_libs/Proj4Leaflet-1.0.1/proj4leaflet.js\"></script>\n<link href=\"../site_libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/leaflet-binding-2.1.2/leaflet.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}