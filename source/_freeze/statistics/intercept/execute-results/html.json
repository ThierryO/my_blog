{
  "hash": "020b0ea2e805ffeee297634fe451898f",
  "result": {
    "markdown": "---\ntitle: To intercept or not to intercept? Is that a question when calculating indices?\ndate: 2018-11-01\nauthor: Thierry Onkelinx\ncategories: [statistics]\nknitr: \n  opts_chunk: \n    echo: true\n    fig.width: 6\n    dev: svg\n---\n\n\n# Indices\n\nLong-term trends in the abundance of species are often communicated as indices.\nThe abundance at some reference point in time is set at 100%.\nSometimes this point in time is a range of years, often it is a single year.\nThe reference point in time is something meaningful for the data: some special date (e.g. new legislation) or the start of the monitoring campaign.\nAlthough, seldom used, one could use the last year in the data as well.\n\nOnce the reference is set, the abundance at the other points in time (mostly years) is expressed as a ratio of the abundance at the reference point in time.\nAn index value of 120% at time point X implies that the abundance at time point X is 1.2 times higher than the abundance at the reference point in time.\n\nFor the sake of simplicity, we will assume that each point in time refers to a specific year.\nHence when we mention \"year\", think of the more general \"point in time\".\n\n# Estimating abundance\n\nIn order to calculate the indices, we need to have an abundance estimate for each year.\nThis is done by applying some statistical model to the data.\nLet us keep things somewhat simple and assume that the data consist of a number of independent Poisson count spanning several years.\nThe data has multiple observations within each year.\nThe observed counts $Y_{ij}$ depend only on a latent variable $\\eta_i$ which only depends on the year $i$.\n\n$$Y_{ij} \\sim \\mbox{Pois}(\\lambda_i) \\\\\n\\log(\\lambda_i) = \\eta_i$$\n\nLet assume two basic models: a linear trend $\\eta_i = \\beta_0 + \\beta_1 x_i$ and a factor trend $\\eta_i = \\alpha_0 + \\alpha_2I_2 + \\dots + \\alpha_iI_i$.\n$I_k$ is a dummy variable where $I_k = 1$ if $i = k$, otherwise $I_k = 0$.\nWe use $\\alpha$ for the parameters of the factor trend and $\\beta$ for those of the linear trend.\n\n# Calculating an index based on the model parameters\n\nThe intercept of a model is the estimated value at the reference state of the data.\nIn case of a continuous covariate, the covariate $x_i = 0$.\nIn case of a categorical variable, all of the associated dummy variables are $I_k = 0$.\nSo if we choose the covariates carefully, we can directly use the intercept to estimate the abundance at the reference year.\nWe obtain this for the linear trend by setting $x_i$ to the number of years since the reference year.\nAt the reference year we get $x_i = 0$, two year after the reference year we get $x_i = 2$, $x_i = -5$ refers to 5 years before the reference year.\nIn case of the factor trend, we make sure that the reference year is used as the reference level of the factor.\n\nNote that since we use a model with a log-link, we need to exponentiate the intercept in order to get an estimate of the abundance.\nSo the estimates at the reference year are $e^{\\beta_0}$ for the linear trend and $e^{\\alpha_0}$ for the factor trend.\n\nThe definition of $\\alpha_k$ in the factor model is the difference between the reference status and the state indicated by the dummy variable $I_k$.\nHence $e^{\\alpha_k}$ is a direct estimate of the value of the index.\nLikewise, $e^{\\beta_1x_i}$ is a direct estimate of the index for the linear trend.\nSince we are statistician, we like a confidence interval around the estimates.\nA straightforward option is to use the standard error of the parameter estimates.\nSo the interval for the index with the factor trend becomes $e^{alpha_k \\pm 1.96 \\sigma_k}$.\nFor the linear trend we get $e^{(\\beta_1\\pm1.96\\sigma_1)x_i}$.\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nset.seed(20181101)\nn_year <- 10\neffort <- 10\nintercept <- 20\ntrend <- 1.05\nsigma_year <- 0.3\n```\n:::\n\n\nWe create an example data with the parameters set above.\nThe data consists of 10 of data.\nThe number of observations in each year is 10 times the number of the year.\nSo the first year has 10 observation while the last year has 100 observations.\nThis reflects an increasing effort during the monitoring.\nA change in monitoring effort is often present in monitoring schemes.\nThe trend in the latent variable $\\eta$ has both a linear component and a first order random walk component.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrw_year <- cumsum(rnorm(n_year, mean = 0, sd = sigma_year))\ntibble(\n  year = rep(seq_len(n_year), effort * seq_len(n_year))\n) %>%\n  mutate(\n    eta = log(intercept) + log(trend) * year + rw_year[year],\n    count = rpois(n(), lambda = exp(eta))\n  ) -> ds\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Simulated data. The points represent the observed counts, the line the true latent variable $\\lambda$.](intercept_files/figure-html/fig-design-1.svg){#fig-design width=576}\n:::\n:::\n\n\nOnce we have the data, we can fit both models.\nWe create two new variables: `start` is a continuous variable centered as the first year, `fstart` is a factor with the first year as reference level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds %>%\n  mutate(\n    start = year - min(year),\n    fstart = factor(start)\n  ) -> ds\nm1_t <- glm(count ~ start, family = poisson, data = ds)\nm1_f <- glm(count ~ fstart, family = poisson, data = ds)\nsummary(m1_f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = count ~ fstart, family = poisson, data = ds)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  3.37417    0.05852  57.658  < 2e-16 ***\nfstart1     -0.08951    0.07278  -1.230    0.219    \nfstart2      0.06732    0.06702   1.004    0.315    \nfstart3      0.37592    0.06334   5.935 2.95e-09 ***\nfstart4      0.54384    0.06182   8.796  < 2e-16 ***\nfstart5      0.47917    0.06147   7.796 6.41e-15 ***\nfstart6      0.59315    0.06079   9.758  < 2e-16 ***\nfstart7      0.78803    0.06016  13.099  < 2e-16 ***\nfstart8      0.59717    0.06028   9.906  < 2e-16 ***\nfstart9      0.76164    0.05987  12.721  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 1812.33  on 549  degrees of freedom\nResidual deviance:  581.48  on 540  degrees of freedom\nAIC: 3769.5\n\nNumber of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\nThis leaves us with the task of calculating the indices based on the trend parameters.\nThe first task is the extract the parameters estimates and their standard errors from the model object and keep only the relevant parameters.\nAnd then we can calculate the indices and their confidence intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(m1_t) %>%\n  coefficients() %>%\n  as.data.frame() %>%\n  rownames_to_column(\"parameter\") %>%\n  filter(parameter != \"(Intercept)\") %>%\n  merge(\n    distinct(ds, start, year)\n  ) %>%\n  mutate(\n    index = exp(start * Estimate),\n    lcl = exp(start * (Estimate - 1.96 * `Std. Error`)),\n    ucl = exp(start * (Estimate + 1.96 * `Std. Error`)),\n    model = \"linear\"\n  ) -> m1_t_index\nsummary(m1_f) %>%\n  coefficients() %>%\n  as.data.frame() %>%\n  rownames_to_column(\"parameter\") %>%\n  filter(parameter != \"(Intercept)\") %>%\n  mutate(\n    year = gsub(\"fstart\", \"\", parameter) %>%\n      as.integer() + 1,\n    index = exp(Estimate),\n    lcl = exp(Estimate - 1.96 * `Std. Error`),\n    ucl = exp(Estimate + 1.96 * `Std. Error`),\n    model = \"factor\"\n  ) -> m1_f_index\n```\n:::\n\n\nNotice that the factor model has no index for the reference year 1.\nWhy? Because we have no trend parameter for the reference year.\nWe can argue that there is no change in the reference year and hence the index and its confidence interval should be set at 100%.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Indices based on the trend parameters when the first year is used as reference.](intercept_files/figure-html/fig-indices-first-1.svg){#fig-indices-first width=576}\n:::\n:::\n\n\n# Changing the reference year\n\nWhat happens if we choose another year as reference year? Suppose we want to use the tenth year of the data as reference.\nIn case of the linear trend we define a new variable $y_i = x_i + 9$, were $x_i$ was the variable with the first year as reference.\nThe form of the model doesn't change and neither do the fitted values change.\nHence we get\n\n$$\\eta_i = \\beta_0 + \\beta_1x_i = \\gamma_0 + \\gamma_1y_i$$\n\nWhen $y_i = 0$, $x_i = 9$ and then $\\beta_0 + 9 \\beta_1 = \\gamma_0$.\nNext we set $x_i = 0$, $y_i = -9$ and then $\\beta_0 = \\gamma_0 + -9 \\gamma_1$.\nWe can fill in $\\gamma_0$ from the previous result so $\\beta_0 = \\beta_0 + 9 \\beta_1 + -9 \\gamma_1$ which leads to $\\beta_1 = \\gamma_1$.\nHence changing the reference year for the linear trend has no effect on the slope.\nOf course the intercept must change.\n\nSomething similar happens with the factor model.\nWe now use another indicator variable $J_k$ which is always zero at the new reference year.\nIn the first equation $k = 1$ is used as reference, in the second $k = i$.\n\n$$\\eta_i = \\alpha_0 + \\alpha_2I_2 + \\dots + \\alpha_iI_i = \\tau_0 + \\tau_1J_1 + \\tau_2J_2 + \\dots + \\tau_{i-1}J_{i-1}$$\n\nWhen $k = j$ and $j \\ne i$ and $j \\ne 1$, we get $alpha_0 + \\alpha_j = \\tau_0 + \\tau_j$.\n$k = i$, yields $\\alpha_0 + \\alpha_i = \\tau_0$ which we can substitute in the first equation $alpha_0 + \\alpha_j = \\alpha_0 + \\alpha_i + \\tau_j$ or $\\alpha_j - \\alpha_i = \\tau_j$.\nSo basically the new intercept $\\tau_0$ is the old intercept $\\alpha_0$ plus the difference between the estimate for the old reference year and the new reference year $\\alpha_i$.\nAll change parameter compensate this by adding $-\\alpha_i$.\n\n## Example\n\nIn the example we create two new reference variables `end` and `fend`.\nAfter fitted the new models we ensure that the model fits are identical to the models fit on `start` and `fstart`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nds %>%\n  mutate(\n    end = year - max(year),\n    fend = fct_rev(fstart)\n  ) -> ds\nm2_t <- glm(count ~ end, family = poisson, data = ds)\nm2_f <- glm(count ~ fend, family = poisson, data = ds)\nall.equal(fitted(m1_t), fitted(m2_t))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nall.equal(fitted(m1_f), fitted(m2_f))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nsummary(m2_f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = count ~ fend, family = poisson, data = ds)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  4.13581    0.01265 327.069  < 2e-16 ***\nfend8       -0.16447    0.01922  -8.558  < 2e-16 ***\nfend7        0.02639    0.01883   1.402    0.161    \nfend6       -0.16848    0.02074  -8.123 4.56e-16 ***\nfend5       -0.28247    0.02266 -12.467  < 2e-16 ***\nfend4       -0.21780    0.02361  -9.224  < 2e-16 ***\nfend3       -0.38571    0.02735 -14.105  < 2e-16 ***\nfend2       -0.69432    0.03503 -19.820  < 2e-16 ***\nfend1       -0.85114    0.04508 -18.879  < 2e-16 ***\nfend0       -0.76164    0.05987 -12.721  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 1812.33  on 549  degrees of freedom\nResidual deviance:  581.48  on 540  degrees of freedom\nAIC: 3769.5\n\nNumber of Fisher Scoring iterations: 4\n```\n:::\n:::\n\n\nNext we use nearly the same code to calculate the indices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(m2_t) %>%\n  coefficients() %>%\n  as.data.frame() %>%\n  rownames_to_column(\"parameter\") %>%\n  filter(parameter != \"(Intercept)\") %>%\n  merge(\n    distinct(ds, end, year)\n  ) %>%\n  mutate(\n    index = exp(end * Estimate),\n    lcl = exp(end * (Estimate - 1.96 * `Std. Error`)),\n    ucl = exp(end * (Estimate + 1.96 * `Std. Error`)),\n    model = \"linear\"\n  ) -> m2_t_index\nsummary(m2_f) %>%\n  coefficients() %>%\n  as.data.frame() %>%\n  rownames_to_column(\"parameter\") %>%\n  filter(parameter != \"(Intercept)\") %>%\n  mutate(\n    year = gsub(\"fend\", \"\", parameter) %>%\n      as.integer() + 1,\n    index = exp(Estimate),\n    lcl = exp(Estimate - 1.96 * `Std. Error`),\n    ucl = exp(Estimate + 1.96 * `Std. Error`),\n    model = \"factor\"\n  ) -> m2_f_index\n```\n:::\n\n\nThe figure below illustrates the new trend.\nOf course, the indices are shifted so that the last year now equals 100%.\nSomething more important is that change in the confidence intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbind_rows(m2_t_index, m2_f_index) %>%\n  ggplot(aes(x = year, y = index, ymin = lcl, ymax = ucl)) +\n  geom_hline(yintercept = 1, linetype = 2) +\n  geom_ribbon(aes(fill = model), alpha = 0.2) +\n  geom_line(aes(colour = model)) +\n  scale_x_continuous(breaks = seq_len(n_year)) +\n  scale_y_continuous(\"Index\", labels = percent)\n```\n\n::: {.cell-output-display}\n![Indices based on the trend parameters when the last year is used as reference.](intercept_files/figure-html/fig-indices-last-1.svg){#fig-indices-last width=576}\n:::\n:::\n\n\nIn order to highlight the differences we scaled to indices with the last year as reference so that the first year equals 100%.\nThe estimates for the indices are now identical.\nHowever, it is now very clear that the confidence intervals of the linear trend are always narrow near the reference year and become wider when we go further away from the reference year.\n\nThe factor trend has, in this case, wider intervals when the first year is used as a reference.\nRecall that the number of observations in the data was low in the earlier years and steadily increases to a maximum in the last year.\nAs a result the standard error of the intercept in the first factor model is larger than the standard error of the second factor model.\nAs a result, the trend parameters also have larger standard errors.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Indices using both reference years but rescaled so that the first year equals 100%.](intercept_files/figure-html/fig-indices-rescaled-1.svg){#fig-indices-rescaled width=576}\n:::\n:::\n\n\nIMHO, changing the reference year should not impact the uncertainty associated with the index.\nFurthermore, the index of the reference year should have some uncertainty attached to it since the abundance in the reference year is estimated from the data just like the abundance in any other year.\n\n# Solution: estimate the abundance in each year and then rescale\n\nEstimating the abundance is straightforward, we just need to get a prediction (and its standard error) for each year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnd <- distinct(ds, year, start, fstart, end, fend)\nfit_1t <- predict(m1_t, newdata = nd, se.fit = TRUE)\nfit_2t <- predict(m2_t, newdata = nd, se.fit = TRUE)\nfit_1f <- predict(m1_f, newdata = nd, se.fit = TRUE)\nfit_2f <- predict(m2_f, newdata = nd, se.fit = TRUE)\n```\n:::\n\n\nOnce we have the predictions we can calculate the abundance and its confidence interval.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnd %>%\n  mutate(\n    model = \"linear\",\n    reference = \"start\",\n    abundance = exp(fit_1t$fit),\n    abundance_lcl = exp(fit_1t$fit - 1.96 * fit_1t$se.fit),\n    abundance_ucl = exp(fit_1t$fit + 1.96 * fit_1t$se.fit)\n  ) -> abundance_1t\nnd %>%\n  mutate(\n    model = \"linear\",\n    reference = \"end\",\n    abundance = exp(fit_2t$fit),\n    abundance_lcl = exp(fit_2t$fit - 1.96 * fit_2t$se.fit),\n    abundance_ucl = exp(fit_2t$fit + 1.96 * fit_2t$se.fit)\n  ) -> abundance_2t\nnd %>%\n  mutate(\n    model = \"factor\",\n    reference = \"start\",\n    abundance = exp(fit_1f$fit),\n    abundance_lcl = exp(fit_1f$fit - 1.96 * fit_1f$se.fit),\n    abundance_ucl = exp(fit_1f$fit + 1.96 * fit_1f$se.fit)\n  ) -> abundance_1f\nnd %>%\n  mutate(\n    model = \"factor\",\n    reference = \"end\",\n    abundance = exp(fit_2f$fit),\n    abundance_lcl = exp(fit_2f$fit - 1.96 * fit_2f$se.fit),\n    abundance_ucl = exp(fit_2f$fit + 1.96 * fit_2f$se.fit)\n  ) -> abundance_2f\n```\n:::\n\n\nNotice in the figure below that the estimated abundance and its confidence interval does not depend on the reference year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# label: fig-abundance\n# echo: false\n# fig-cap: \"Estimated abundance from the different models\"\nbind_rows(abundance_1f, abundance_1t, abundance_2f, abundance_2t) %>%\n  ggplot(\n    aes(x = year, y = abundance, ymin = abundance_lcl, ymax = abundance_ucl)\n  ) +\n  geom_ribbon(aes(fill = reference), alpha = 0.2) +\n  geom_line(aes(colour = reference)) +\n  scale_x_continuous(breaks = seq_len(n_year)) +\n  facet_wrap(~model)\n```\n\n::: {.cell-output-display}\n![](intercept_files/figure-html/unnamed-chunk-13-1.svg){width=576}\n:::\n:::\n\n\nNow the only thing left to do is to rescale the abundance so that the index at the reference year becomes 100%.\nThis is very easy: find the estimated abundance at the reference year and divided all abundance estimated and their confidence intervals with this single value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabundance_1t %>%\n  filter(year == 1) %>%\n  select(model, base = abundance) %>%\n  inner_join(abundance_1t, by = \"model\") %>%\n  mutate(\n    index = abundance / base,\n    lcl = abundance_lcl / base,\n    ucl = abundance_ucl / base\n  ) -> m1_t_index_good\nabundance_1f %>%\n  filter(year == 1) %>%\n  select(model, base = abundance) %>%\n  inner_join(abundance_1f, by = \"model\") %>%\n  mutate(\n    index = abundance / base,\n    lcl = abundance_lcl / base,\n    ucl = abundance_ucl / base\n  ) -> m1_f_index_good\nabundance_2t %>%\n  filter(year == 10) %>%\n  select(model, base = abundance) %>%\n  inner_join(abundance_2t, by = \"model\") %>%\n  mutate(\n    index = abundance / base,\n    lcl = abundance_lcl / base,\n    ucl = abundance_ucl / base\n  ) -> m2_t_index_good\nabundance_2f %>%\n  filter(year == 10) %>%\n  select(model, base = abundance) %>%\n  inner_join(abundance_2f, by = \"model\") %>%\n  mutate(\n    index = abundance / base,\n    lcl = abundance_lcl / base,\n    ucl = abundance_ucl / base\n  ) -> m2_f_index_good\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Indices based on rescaled abundance.](intercept_files/figure-html/fig-indices-alt-1.svg){#fig-indices-alt width=576}\n:::\n:::\n\n\n# Conclusion\n\nUsing rescaled abundances as indices, yields correct confidence intervals for the indices and they don't depend on the choice of the reference year.\nAn added bonus is that this workflow yields a correct confidence interval for the index at the reference year.\n\nUsing the predicted abundances has a few more nice features:\n\n1. You don't need tweak the year covariate so that the trend parameters are relative to the reference year.\n2. You can rescale the index afterward to any other reference year within the data, without the need to refit the model with an appropriately tweaked year covariate.\n3. You can use more complex models.\n  E.g. a model with a separate intercept and trend for each stratum.\nThe predicted abundance could be some weighted average over the strata.\n\n## Session info\n\nThese R packages were used to create this post.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       Ubuntu 22.04.3 LTS\n system   x86_64, linux-gnu\n ui       X11\n language nl_BE:nl\n collate  nl_BE.UTF-8\n ctype    nl_BE.UTF-8\n tz       Europe/Brussels\n date     2023-09-02\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n cli           3.6.1      2023-03-23 [1] CRAN (R 4.3.0)\n colorspace    2.1-0      2023-01-23 [1] CRAN (R 4.3.0)\n digest        0.6.32     2023-06-26 [1] CRAN (R 4.3.1)\n dplyr       * 1.1.2      2023-04-20 [1] CRAN (R 4.3.0)\n evaluate      0.21       2023-05-05 [1] CRAN (R 4.3.0)\n fansi         1.0.4      2023-01-22 [1] CRAN (R 4.3.0)\n farver        2.1.1      2022-07-06 [1] CRAN (R 4.3.0)\n fastmap       1.1.1      2023-02-24 [1] CRAN (R 4.3.0)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n generics      0.1.3      2022-07-05 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.2      2023-04-03 [1] CRAN (R 4.3.0)\n glue          1.6.2      2022-02-24 [1] CRAN (R 4.3.0)\n gtable        0.3.3      2023-03-21 [1] CRAN (R 4.3.0)\n hms           1.1.3      2023-03-21 [1] CRAN (R 4.3.0)\n htmltools     0.5.5      2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets   1.6.2      2023-03-17 [1] CRAN (R 4.3.0)\n jsonlite      1.8.7      2023-06-29 [1] CRAN (R 4.3.1)\n knitr         1.43       2023-05-25 [1] CRAN (R 4.3.0)\n labeling      0.4.2      2020-10-20 [1] CRAN (R 4.3.0)\n lifecycle     1.0.3      2022-10-07 [1] CRAN (R 4.3.0)\n lubridate   * 1.9.2.9000 2023-05-15 [1] https://inbo.r-universe.dev (R 4.3.0)\n magrittr      2.0.3      2022-03-30 [1] CRAN (R 4.3.0)\n munsell       0.5.0      2018-06-12 [1] CRAN (R 4.3.0)\n pillar        1.9.0      2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig     2.0.3      2019-09-22 [1] CRAN (R 4.3.0)\n purrr       * 1.0.1      2023-01-10 [1] CRAN (R 4.3.0)\n R6            2.5.1      2021-08-19 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n rlang         1.1.1      2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown     2.23       2023-07-01 [1] CRAN (R 4.3.1)\n rstudioapi    0.14       2022-08-22 [1] CRAN (R 4.3.0)\n scales      * 1.2.1      2022-08-20 [1] CRAN (R 4.3.0)\n sessioninfo   1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringi       1.7.12     2023-01-11 [1] CRAN (R 4.3.0)\n stringr     * 1.5.0      2022-12-02 [1] CRAN (R 4.3.0)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyselect    1.2.0      2022-10-10 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n timechange    0.2.0      2023-01-11 [1] CRAN (R 4.3.0)\n tzdb          0.4.0      2023-05-12 [1] CRAN (R 4.3.0)\n utf8          1.2.3      2023-01-31 [1] CRAN (R 4.3.0)\n vctrs         0.6.3      2023-06-14 [1] CRAN (R 4.3.0)\n withr         2.5.0      2022-03-03 [1] CRAN (R 4.3.0)\n xfun          0.39       2023-04-20 [1] CRAN (R 4.3.0)\n yaml          2.3.7      2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /home/thierry/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n",
    "supporting": [
      "intercept_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}