---
title: Estimating densities from a point pattern
author: Thierry Onkelinx
date: "2017-06-28"
categories: [statistics, point pattern]
image: media/prediction.png
params:
  cellsize: 20
knitr: 
  opts_chunk:
    message: false
    fig.width: 6
    dev: svg
---

In this example we focus on a set of 10450 coordinates in a small area.
The goal is to estimate the local density of points, expressed as the number of point per unit area.
The raw coordinates are given in [WGS84 (EPSG:4326)](https://epsg.io/4326), which is a geodetic coordinate system. 
That is not suited for calculating distances, so we need to re-project the points into a local projected coordinate system.
In this case we use [Lambert72 (EPSG:3170)](https://epsg.io/31370).
Next we calculate the density.
To visualise the density, we have to transform the results back in to WGS84. 

The data used in this example is real data by centred to a different location for privacy reasons.
The dataset is available on [GitHub](https://github.com/ThierryO/my_blog/tree/master/data/20170628).

First we must read the data into R.
Plotting the raw data helps to check errors in the data (@fig-raw-data).
The easiest way to plot it, is to convert the dataframe into a simple features object.

```{r}
#| label: fig-raw-data
#| fig-cap: Raw data
library(leaflet)
library(sf)
crs_wgs84 <- st_crs(4326)
read.delim("data/points.txt", sep = " ") |>
  st_as_sf(coords = c("lon", "lat"), crs = crs_wgs84) -> points
leaflet(points) |>
  addTiles() |>
  addCircleMarkers(radius = 1)
```

The original coordinates are in the WGS84 projection.
We need to project them onto a plane by using an appropriate local coordinate system, in this case Lambert72 (EPSG code 31370).

```{r reproject}
crs_lambert <- st_crs(31370)
st_transform(points, crs = crs_lambert) |>
  st_coordinates() |>
  as.data.frame() -> points_lambert
```

Once we have the points into a projected coordinate system, we can calculate the densities.
We start by defining a grid.
`cellsize` is the dimension of the square grid cell in the units of the projected coordinate system.
Meters in case of Lambert72.
The boundaries of the grid are defined using `pretty()`, which turns a vector of numbers into a "pretty" vector with rounded numbers.
The combination of the boundaries and the cell size determine the number of grid cells `n` in each dimension.
`diff()` calculates the difference between to adjacent numbers of a vector.
The density is calculated with `MASS::kde2d()` based on the vectors with the longitude and latitude, the number of grid cells in each dimension and the boundaries of the grid.
This returns the grid as a list with elements `x` (a vector of longitude coordinates of the centroids), `y` (a vector of latitude coordinates of the centroids) and `z` (a matrix with densities).
The values in `z` are densities for the 'average' point per unit area.
When we multiply the value `z` with the area of the grid cell and sum all of them we get 1.
So if we multiple `z` with the number of points we get the density of the points per unit area.

We use [`dplyr::mutate()`](http://dplyr.tidyverse.org/) to convert it into a `data.frame`.
The last two steps convert the centroids into a set of coordinates for square polygons.

```{r density}
library(MASS)
library(dplyr)
xlim <- range(pretty(points_lambert$X)) + c(-100, 100)
ylim <- range(pretty(points_lambert$Y)) + c(-100, 100)
n <- c(diff(xlim), diff(ylim)) / params$cellsize + 1
dens <- kde2d(
  x = points_lambert$X, y = points_lambert$Y, n = n, lims = c(xlim, ylim)
)
dx <- diff(dens$x[1:2])
dy <- diff(dens$y[1:2])
sum(dens$z * dx * dy)
expand.grid(lon = dens$x, lat = dens$y) |>
  mutate(
    density = as.vector(dens$z) * length(points_lambert),
    id = seq_along(.data$density)
  ) -> dens
```

In order to visualise the result, we have to do a few step.
First convert the dataframe into a simple object with points.
Then convert the points into a grid of polygons.
Next we attach the estimated density as counts per grid cell.
Finally we re-project the coordinates back to WGS84.
Then we can display the grid with a web based background image (@fig-density).

```{r}
#| label: dens-wgs84
dens |>
  st_as_sf(coords = c("lon", "lat"), crs = crs_lambert) |>
  st_make_grid(
    cellsize = c(dx, dy),
    offset = c(min(dens$lon) - dx / 2, min(dens$lat) - dy / 2)
  ) |>
  st_as_sf() |>
  mutate(
    density = dens$density * params$cellsize ^ 2
  ) |>
  st_transform(crs = crs_wgs84) -> dens_wgs84
```

`leaflet` requires a predefined function with a colour pallet.
We use `leaflet::colorNumeric()` to get a continuous pallet.
Setting `stroke = FALSE` removes the borders of the polygon.
`fillOpacity` sets the transparency of the polygons.

```{r}
#| label: fig-density
#| fig.cap: Estimated density (number of points per grid cell)
pal <- colorNumeric(
  palette = rev(rainbow(100, start = 0, end = .7)),
  domain = c(0, dens_wgs84$density)
)
map <- leaflet(dens_wgs84) |>
  addTiles() |>
  addPolygons(color = ~pal(density), stroke = FALSE, fillOpacity = 0.5) |>
  addLegend(pal = pal, values = ~density)
map
```

```{r}
#| label: thumbnail
#| results: hide
#| echo: false
junk <- mapview::mapshot(map, file = "media/prediction.png")
```

## Session info

These R packages were used to create this post.

```{r}
#| label: session-info
sessioninfo::session_info()
```
